
# 高速化に向けて

このページでは，シングルサイクル・マシンが完成した人向けに，プロセッサをさらに高速化するための方法について説明しています．


## パイプライン化

パイプライン化そのものについては，教科書を読んで理解してください．

ここでは，FPGA 上でパイプライン化を行う際にメモリ部分が問題となるため，この部分について解説します．

### メモリ

実験用に用意されている命令メモリとデータ・メモリは入力がラッチされており，アドレスやデータを入れてから1サイクル後に出力が得られます．
シングルサイクル・マシンの時は，メモリにのみ4倍速クロックを入れることで，見かけ上は1サイクル内にデータが出力されるようにしてました．

これに対し，パイプライン化を行う際は，うまく工夫することで等速クロックのみで動作させることができます．

以下の図は PC と命令メモリを接続したものです．命令メモリは，アドレス入力を保持するラッチとメモリ本体とみなすことができます．PC の出力を命令メモリに入力すると，そのままでは命令データが出てくるのが1サイクル後になってしまいます．これに対し，以下の図のように PC への書き込みを命令メモリに対して平行して入力することにより，次のサイクルでは命令メモリの結果を得ることができます．

この図のように実装した場合，CPUとメモリには同じ速さのクロック（具体的には4倍速クロック）を入力する必要があります．

![imem-pipe](imem-pipe.png)

#### データメモリへの書き込み
前述のように，シングルサイクル・マシンはメモリに4倍速クロックを入れることで実現しています．
メモリがCPUより高速な場合，CPUでデータメモリへの入力が決定される前にデータメモリに不正な書き込みが起こる場合があります．
これを防ぐため，シングルサイクル・マシンのCPUはサイクルの後半にだけデータメモリへの書き込み信号を立てるようになっています．

この，サイクルの後半にだけデータメモリへの書き込み信号を立てる操作は，パイプライン化を行ってメモリとCPUが同じ速度で動作するようにした際には不要となるため，削除する必要があります．
具体的には，Main.v内のalways_comb節にある対応するコードを削除すればよいです．
## ソート専用命令

たとえば min（2つのソースのうち，小さい方を選択して出力），max（その逆）などを追加してそれを利用すると速くできる･･･かもしれないです．

## キャッシュ

パイプラインのチューニングを行っていくと，クリティカル・パスは最終的にデータ・メモリへアクセスを行う部分になると思います．
これを乗り越えてさらにクロック周波数を上げる方法としては，データ・メモリにキャッシュを追加する方法があります．
キャッシュへのアクセスは1サイクルで，データ・メモリへのアクセスは2サイクル以上かけて行うようにすることで，プロセッサのクリティカル・パスからデータ・メモリを切り離す事ができるようになります．

### キャッシュ・ミス時のデータ・メモリへのアクセス方法
キャッシュ・ミスが発生した場合，時間をかけてデータ・メモリにアクセスする必要があります．
これを実現するためには，たとえば以下のようにします．
* データ・メモリへのクロックとして1/2周期のものを入れる
    * シングル・サイクル・マシンの時と逆になりますが，2種類のクロックを作る方法は同じです．
* ミスが発生した場合，プロセッサ全体をストールさせてデータ・メモリ・アクセスを行い，場合によってはキャッシュを更新する

### スクラッチパッド
キャッシュはヒット・ミス判定や，キャッシュからの書き戻しなど色々制御が複雑になるため，より簡単な方法としてスクラッチパッドというものがあります．
これは，小さなメモリをデータ・メモリとは別に用意し，そこにアクセスする限りは速いと言う点ではキャッシュと同じです．
しかし，キャッシュとは違い，データとのやりとりはプログラマが手動で行います．

たとえば
* アドレス 0x0000 から 0x3ff は スクラッチパッドとして小さなメモリを接続しておき，1サイクルでアクセス可能
* アドレス 0x400 から 0x3fff はデータメモリを接続して2サイクルでアクセス可能

と言うようにし，処理を行う場合は，一度データ・メモリ（0x400 から 0x3fff ）からロードして，自分でスクラッチパッド（0x000 から 0x3ff）に ストア，その後スクラッチパッド内で処理を行う･･･と言うようになります．

## 実行フラグ（プレディケーション）
ソートでは大量の分岐を行うため，それが足を引っ張って速度が出ない場合があります．

分岐を行わずに実行を行う方法として，実行フラグを用いた方法があります．

実行フラグを用いた方法では，追加のソース・オペランドの内容に従い，それが1であれば本来の命令と同様に実行，0であればNOPとして扱うと言うものです．
if-then-else の両パスの処理を書いておき，片方だけが実行されるようにすれば，分岐を一切使わずに同様の処理を書く事ができます．


## SIMD 命令

SIMD 命令とは，1つの命令によって複数のデータを同時に処理する命令のことです．
SIMD 命令では，1つのレジスタに2から4個のデータを格納できるようにしておき，1つの命令で格納されている複数のデータに対して同時に処理を行います．

## VLIW

VLIW では，お互いに依存がない命令同士を2から4程度まとめて1つの大きな命令とし，それを一気に処理します．
命令の並びはプログラマ（コンパイラ）があらかじめ依存がない命令同士を組み合わせて配置する必要があります．
スーパスカラとは異なり，ハードウェアでは依存の解析を行う必要がないため，単純な実装で実現できます．

## スーパスカラ
スーパスカラ・プロセッサでは，命令の依存関係を解析し，お互いが並列して実行できる場合はそれらを並列して実行します．
もし依存関係があった場合は後続の命令を待たせて，依存関係を満たすように制御を行います．


## Out-of-Order スーパスカラ
Out-of-Order スーパスカラでは，ハードウェアで並列に実行できる命令を検出し，並び替えを行って並列に実行します．
ここまで説明した色々な方法の中でも最も高度であり，実装も難しいです．
